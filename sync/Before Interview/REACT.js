// ############# 	React API верхнего уровня	####################

MyComponent extends React.PureComponent //создаёт компонент с реализованным souldComponentUpdate, поверхностно сравнивающим props и state

React.memo(MyComponent, areEqual) //не перерендеривает MyComponent при неизменных props (поверхностное сравнение). Второй необязательный аргумент - функция, получающая на вход prevProps и nextProps, должна вернуть true для одинаковых props (не перерендеривать)

React.Children:
React.Children.map(children, function[(thisArg)]); // Вызывает функцию для каждого непосредственного потомка, содержащегося в children передавая их по очереди в thisArg. Если children равен null или undefined, этот метод вернёт null или undefined, а не массив.
React.Children.forEach(children, function[(thisArg)]); // Похож на React.Children.map(), но не возвращает массив.
React.Children.count(children); // Возвращает общее количество компонентов в children, равное числу раз которое будет вызван обратный вызов, переданный в map или forEach.
React.Children.only(children); // Проверяет, что у children есть только один потомок (React элемент), и возвращает его. Иначе этот метод выдаёт ошибку.
React.Children.toArray(children); // Возвращает непрозрачную структуру данных children в виде плоского массива с ключами, заданные каждому дочернему элементу.

React.createRef() //создаёт реф, который можно прикрепить к React-элементам через атрибут ref.

const MyComponent = React.forwardRef((props, ref) => {}) // функция должна возвращать узел React. React будет вызывать эту функцию с пропсами и рефом в качестве двух аргументов. Переданый в MyComponent в качестве параметра реф будет передан потомку и может использоваться из родителя.

const SomeComponent = React.lazy(() => import('./SomeComponent')); // позволяет вам определять компонент, который загружается динамически. Это помогает уменьшить размер сборки, откладывая загрузку компонентов, которые не используются во время первоначального рендера. Требуется чтобы выше в дереве находился компонент <React.Suspense>.

<React.Suspense fallback={<Spinner />}>...</React.Suspense> // позволяет показать индикатор загрузки в случае, если некоторые компоненты в дереве под ним ещё не готовы к рендеру.

// ############# 	REACT HOOKS	####################

Основные хуки.
useState: const [state, setState] = useState(value || () => {}); // функция вычистлится один раз, должна вернуть начальное состояние.
useEffect: useEffect(() => {}, []); // из колбека возвращается функция, которая будет вызвана перед размонтирование компонента
useContext: const value = useContext(MyContext); // Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.

Дополнительные хуки.
useReducer: const [state, dispatch] = useReducer(reducer, initialArg, init); // Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. функция init (если передана) задаёт начальное состояние как init(initialArg)
useCallback: const memoizedCallback = useCallback(() => {doSomething(a, b);}, [a, b]); // возвращает мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров
useMemo: const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); // будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере.
useRef: const refContainer = useRef(initialValue); // возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента. Можно использовать в качестве императивной ссылки на DOM-элемент. Ещё он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах.
useImperativeHandle: useImperativeHandle(ref, createHandle, [deps]); // Используется совместно с forwardRef.
useLayoutEffect: useLayoutEffect(() => {}, []); // аналог useEffect, но выполняемый синхронно после всех изменений DOM. Обновления, запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.
useDebugValue: useDebugValue(value); // может использоваться для отображения метки для пользовательских хуков в React DevTools.

Хуки react-router-dom
useHistory:
useLocation:

Хуки redux
useDispatch:
useSelector:






// ############# 	БИБЛИОТЕКИ	####################
VideoJS from React : npm i react-video-js-player // плеер для проигрывания видео.
